#!/usr/bin/env node

/**
 * FILE WRITER FOR DESIGN-TO-CODE SYSTEM
 * Uses fs-extra for robust file operations following Context7 best practices
 * AI-first approach: let AI decide file names, paths, and structure
 */

import fs from 'fs-extra';
import { join, dirname, resolve } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Get the target UI directory (atomic-design-pattern/ui/)
 */
const getUIDirectory = () => {
  // Use OUTPUT_DIR from environment or fallback
  // Path should be relative to design-to-code-system/ directory
  const outputDir = process.env.OUTPUT_DIR || '../atomic-design-pattern/ui';
  // Resolve from design-to-code-system/utils/ directory
  return resolve(__dirname, '..', outputDir);
};

/**
 * Ensure the complete UI directory structure exists
 * Uses fs-extra's ensureDir for atomic directory creation
 */
export const ensureUIDirectoryStructure = async () => {
  const uiDir = getUIDirectory();

  const directories = [
    uiDir,                          // Base UI directory
    join(uiDir, 'elements'),        // Atomic components (atoms -> elements)
    join(uiDir, 'components'),      // Molecule components (molecules -> components)
    join(uiDir, 'modules'),         // Organism components (organisms -> modules)
  ];

  console.log(`üìÅ Ensuring UI directory structure at: ${uiDir}`);

  try {
    // Use fs-extra's ensureDir for each directory
    await Promise.all(
      directories.map(dir => fs.ensureDir(dir))
    );

    console.log('‚úÖ UI directory structure created successfully');

    return {
      baseDir: uiDir,
      directories: {
        elements: join(uiDir, 'elements'),      // atoms -> elements
        components: join(uiDir, 'components'),  // molecules -> components
        modules: join(uiDir, 'modules'),        // organisms -> modules
      }
    };

  } catch (error) {
    throw new Error(`Failed to create UI directory structure: ${error.message}`);
  }
};

/**
 * Format TypeScript React component code with proper imports and exports
 * Ensures Tailwind CSS + cn() utility usage following project patterns
 */
export const formatComponentCode = (component) => {
  const {
    name,
    type,
    code,
    description,
    props = [],
    dependencies = []
  } = component;

  // Basic validation
  if (!name || !code) {
    throw new Error('Component must have name and code');
  }

  // Clean the code by removing existing imports to prevent duplicates
  let cleanedCode = code
    .replace(/^import.*from\s+['"]react['"];?\s*\n?/gm, '') // Remove React imports
    .replace(/^import.*from\s+['"]@\/lib\/utils['"];?\s*\n?/gm, '') // Remove utils imports
    .replace(/^import.*\.css['"];?\s*\n?/gm, '') // Remove CSS imports
    .replace(/^\s*\n/gm, '') // Remove empty lines at start
    .trim();

  // Build proper imports
  const imports = [];

  // Always include React with proper TypeScript types
  if (cleanedCode.includes(': FC') || cleanedCode.includes('React.FC')) {
    imports.push("import React, { FC } from 'react';");
  } else {
    imports.push("import React from 'react';");
  }

  // Add cn utility if component uses className logic or needs it
  if (cleanedCode.includes('className') || cleanedCode.includes('clsx') ||
      cleanedCode.includes('classNames') || type === 'atom') {
    imports.push("import { cn } from '@/lib/utils';");
  }

  // Add other dependencies (excluding react which is already handled)
  dependencies.forEach(dep => {
    if (dep === 'react') return;
    if (dep.startsWith('@/')) {
      imports.push(`import { } from '${dep}';`);
    }
  });

  // Build the header
  const header = [
    '/**',
    ` * ${name} Component`,
    description ? ` * ${description}` : ` * A reusable ${name} component`,
    ` * Generated by AI-driven design-to-code system`,
    ` * Type: ${type || 'component'}`,
    ` * @generated ${new Date().toISOString()}`,
    ' */'
  ].join('\n');

  // Build import section
  const importSection = imports.join('\n');

  // Ensure proper export
  if (!cleanedCode.includes('export default') && !cleanedCode.includes('export const')) {
    cleanedCode += `\n\nexport default ${name};`;
  }

  // Combine all sections with proper spacing
  return [header, importSection, cleanedCode].join('\n\n');
};

/**
 * Determine the appropriate directory for a component based on its type
 * AI-first: respect AI's component categorization decisions
 */
export const getComponentDirectory = (component, uiStructure) => {
  const { type, uiCategory } = component;

  // Let AI's categorization take precedence
  if (uiCategory && uiStructure.directories[uiCategory]) {
    return uiStructure.directories[uiCategory];
  }

  // Fallback to type-based mapping
  const typeMapping = {
    'atom': uiStructure.directories.atoms,
    'molecule': uiStructure.directories.molecules,
    'organism': uiStructure.directories.organisms,
  };

  return typeMapping[type] || uiStructure.directories.elements; // Default to elements
};

/**
 * Generate a safe filename from component name
 * AI-first: respect AI's naming, but ensure filesystem safety
 */
export const generateSafeFileName = (componentName) => {
  // Ensure PascalCase for React components
  const pascalName = componentName
    .split(/[-_\s]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');

  // Ensure it starts with uppercase (React convention)
  const safeName = pascalName.charAt(0).toUpperCase() + pascalName.slice(1);

  return `${safeName}.tsx`;
};

/**
 * Write a component to file using fs-extra's outputFile
 * This automatically creates directories and handles all file operations atomically
 */
export const writeComponentFile = async (component) => {
  try {
    console.log(`üìù Writing component: ${component.name} (${component.type})`);

    // Ensure UI directory structure exists
    const uiStructure = await ensureUIDirectoryStructure();

    // Determine target directory (let AI decide via component properties)
    const targetDir = getComponentDirectory(component, uiStructure);

    // Generate safe filename
    const fileName = generateSafeFileName(component.name);
    const filePath = join(targetDir, fileName);

    // Format the component code
    const formattedCode = formatComponentCode(component);

    // Write file using fs-extra's outputFile (creates directories automatically)
    await fs.outputFile(filePath, formattedCode, 'utf8');

    console.log(`‚úÖ Component written: ${filePath}`);

    return {
      filePath,
      fileName,
      directory: targetDir,
      relativePath: `ui/${targetDir.split('/ui/')[1]}/${fileName}`,
      size: formattedCode.length,
      writtenAt: new Date().toISOString()
    };

  } catch (error) {
    throw new Error(`Failed to write component ${component.name}: ${error.message}`);
  }
};

/**
 * Write multiple components to files
 * AI-first: respect AI's component organization and structure
 */
export const writeComponentFiles = async (components) => {
  try {
    console.log(`üìù Writing ${components.length} components to files...`);

    // Ensure directory structure first
    await ensureUIDirectoryStructure();

    // Write all components in parallel for speed
    const results = await Promise.all(
      components.map(component => writeComponentFile(component))
    );

    // Generate summary
    const summary = {
      totalComponents: results.length,
      byType: {},
      byDirectory: {},
      files: results,
      completedAt: new Date().toISOString()
    };

    // Count by type and directory
    results.forEach(result => {
      const type = result.directory.split('/').pop(); // Extract directory name
      summary.byType[type] = (summary.byType[type] || 0) + 1;
      summary.byDirectory[result.directory] = (summary.byDirectory[result.directory] || 0) + 1;
    });

    console.log(`‚úÖ All components written successfully!`);
    console.log(`üìä Summary: ${JSON.stringify(summary.byType, null, 2)}`);

    return summary;

  } catch (error) {
    throw new Error(`Failed to write component files: ${error.message}`);
  }
};

/**
 * Validate that written files are properly formatted and importable
 */
export const validateWrittenFiles = async (filePaths) => {
  try {
    console.log(`üîç Validating ${filePaths.length} written files...`);

    const results = [];

    for (const filePath of filePaths) {
      const validation = {
        filePath,
        exists: false,
        readable: false,
        hasExport: false,
        hasTSX: false,
        hasReact: false,
        size: 0,
        errors: []
      };

      try {
        // Check if file exists and is readable
        const stats = await fs.stat(filePath);
        validation.exists = true;
        validation.size = stats.size;

        const content = await fs.readFile(filePath, 'utf8');
        validation.readable = true;

        // Basic content validation
        validation.hasExport = /export\s+(default\s+|const\s+|function\s+)/.test(content);
        validation.hasTSX = content.includes('tsx') || content.includes('React.FC') || content.includes('<');
        validation.hasReact = content.includes('import React') || content.includes('from \'react\'');

        if (!validation.hasExport) {
          validation.errors.push('Missing export statement');
        }
        if (!validation.hasReact) {
          validation.errors.push('Missing React import');
        }

      } catch (error) {
        validation.errors.push(`File validation error: ${error.message}`);
      }

      results.push(validation);
    }

    const successCount = results.filter(r => r.exists && r.readable && r.hasExport && r.errors.length === 0).length;

    console.log(`‚úÖ File validation complete: ${successCount}/${results.length} files valid`);

    return {
      totalFiles: results.length,
      validFiles: successCount,
      results,
      success: successCount === results.length
    };

  } catch (error) {
    throw new Error(`File validation failed: ${error.message}`);
  }
};

/**
 * Create a comprehensive index file for easy imports
 * AI-first: let AI decide what components should be exported
 */
export const createIndexFile = async (components, directory) => {
  try {
    const indexPath = join(directory, 'index.ts');

    const exports = components
      .map(comp => {
        const fileName = generateSafeFileName(comp.name).replace('.tsx', '');
        return `export { default as ${comp.name} } from './${fileName}';`;
      })
      .join('\n');

    const indexContent = [
      '/**',
      ' * Auto-generated index file',
      ' * Exports all components in this directory',
      ` * Generated: ${new Date().toISOString()}`,
      ' */',
      '',
      exports,
      ''
    ].join('\n');

    await fs.outputFile(indexPath, indexContent, 'utf8');

    console.log(`üìã Index file created: ${indexPath}`);

    return indexPath;

  } catch (error) {
    throw new Error(`Failed to create index file: ${error.message}`);
  }
};

export default {
  ensureUIDirectoryStructure,
  formatComponentCode,
  writeComponentFile,
  writeComponentFiles,
  validateWrittenFiles,
  createIndexFile,
  getUIDirectory
};